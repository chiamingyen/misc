

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Theory of Operation &mdash; Leo 4.9 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Leo 4.9 documentation" href="index.html" />
    <link rel="next" title="White Papers" href="whitepapers.html" />
    <link rel="prev" title="History of Leo" href="history.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="whitepapers.html" title="White Papers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="history.html" title="History of Leo"
             accesskey="P">previous</a> |</li>
        <li><a href="leo_toc.html">Leo 4.9 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="theory-of-operation">
<h1><a class="toc-backref" href="#id1">Theory of Operation</a><a class="headerlink" href="#theory-of-operation" title="Permalink to this headline">¶</a></h1>
<p>This chapter discusses how Leo&#8217;s code works,
paying particular attention to topics that have caused difficulties in design or implementation.
This chapter will be of use primarily to those wanting to change Leo&#8217;s code.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#theory-of-operation" id="id1">Theory of Operation</a><ul>
<li><a class="reference internal" href="#autocompletion" id="id2">Autocompletion</a></li>
<li><a class="reference internal" href="#clones" id="id3">Clones</a></li>
<li><a class="reference internal" href="#drawing-and-events" id="id4">Drawing and events</a></li>
<li><a class="reference internal" href="#find-and-change-commands" id="id5">Find and change commands</a></li>
<li><a class="reference internal" href="#key-handling" id="id6">Key handling</a></li>
<li><a class="reference internal" href="#nodes" id="id7">Nodes</a></li>
<li><a class="reference internal" href="#overview" id="id8">Overview</a></li>
<li><a class="reference internal" href="#unicode" id="id9">Unicode</a></li>
<li><a class="reference internal" href="#unlimited-undo" id="id10">Unlimited undo</a></li>
<li><a class="reference internal" href="#leo-s-load-process" id="id11">Leo&#8217;s load process</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="autocompletion">
<h2><a class="toc-backref" href="#id2">Autocompletion</a><a class="headerlink" href="#autocompletion" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ui-notes">
<h3>UI notes<a class="headerlink" href="#ui-notes" title="Permalink to this headline">¶</a></h3>
<p>Both the legacy and new completer now work <em>exactly</em> the same way, because
they both use the AutoCompleterClass to compute the list of completions.</p>
<p>The strict &#8220;stateless&#8221; requirement means that the &#8220;intermediate&#8221;
completions must be entered into the body pane while completion is active.
It works well as a visual cue when using the tabbed completer: indeed, the
tabbed completer would be difficult to use without this cue.</p>
<p>The situation is slightly different with the qcompleter. Adding code before
the user accepts the completion might be considered an &#8220;advanced&#8221; feature.
However, it does have two important advantages, especially when &#8220;chaining&#8221;
across periods: it indicates the status of the chaining and it limits what
must appear in the qcompleter window.</p>
</div>
<div class="section" id="appearance">
<h3>Appearance<a class="headerlink" href="#appearance" title="Permalink to this headline">¶</a></h3>
<p>There is little change to the legacy completer, except that no text is
highlighted in the body pane during completion. This is calmer than before.
Furthermore, there is no longer any need for highlighting, because when the
user types a backspace the legacy completer now simply deletes a single
character instead of the highlighted text.</p>
<p>One minor change: the legacy completer now <em>does</em> insert characters that do
not match the start of any possible completion. This is an experimental
feature, but it might play well with using codewise completions as a
fallback to Leo-related completions.</p>
</div>
<div class="section" id="performance">
<h3>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h3>
<p>Performance of Leo-related completions is <em>much</em> better than before. The
old code used Python&#8217;s inspect module and was horribly complex. The new
code uses eval and is perfectly straightforward.</p>
<p>The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up backspacing. Global
caching is possible because completions depend <em>only</em> on the present
prefix, <em>not</em> on the presently selected node. If ContextSniffer were used,
completions would depend on the selected node and caching would likely be
impractical. Despite these improvements, the performance of
codewise-oriented completions is noticeably slower than Leo-related
completions.</p>
<p>The ac.get_cached_options cuts back the prefix until it finds a cached
prefix. ac.compute_completion_list then uses this
(perhaps-way-too-long-list) as a starting point, and computes the final
completion list by calling g.itemsMatchingPrefixInList.</p>
<p>This may not be absolutely the fastest way, but it is much simpler and more
robust than attempting to do &#8220;prefix AI&#8221; based on comparing old and new
prefixes. Furthermore, this scheme is completely independent of the how
completions are actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.</p>
<p>In most cases the scheme is extremely fast: calls to get_completions
replace calls to g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have thousands of
items. Scanning large lists can&#8217;t be helped in any case for short prefixes.</p>
<p>Happily, the new scheme is still <em>completely</em> stateless: the completionDict
does <em>not</em> define state (it is valid everywhere) and no state variables had
to be added. In short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.</p>
</div>
</div>
<div class="section" id="clones">
<h2><a class="toc-backref" href="#id3">Clones</a><a class="headerlink" href="#clones" title="Permalink to this headline">¶</a></h2>
<p>New in Leo 4.7. All clones of a node <strong>are the same node</strong>. This is the
so-called <strong>one-node</strong> world. In this world, vnodes represent data, generators
and positions represent the location of the data in an outline.  This is a much
simpler world than all previous data representations.</p>
<p>In Leo versions 4.2 to 4.6 clones were represented by sharing <strong>tnodes</strong>. Cloned
vnodes shared the same tnode. This shared tnode represented the entire shared
subtree of both clones. Thus, the _firstChild link had to reside in
<em>tnodes</em>, not <em>vnodes</em>.</p>
<p>Prior to Leo version 4.2, Leo duplicated all the descendants of vnode v when
cloning v. This created many complications that were removed in the shared tnode
world. In particular, in the shared tnode scheme a vnode v is cloned if and only
if len(v.vnodeList) &gt; 1.</p>
</div>
<div class="section" id="drawing-and-events">
<h2><a class="toc-backref" href="#id4">Drawing and events</a><a class="headerlink" href="#drawing-and-events" title="Permalink to this headline">¶</a></h2>
<p>Leo must redraw the outline pane when commands are executed and as the result of mouse and keyboard events.
The main challenges are eliminating flicker and handling events properly.
These topics are interrelated.</p>
<p><strong>Eliminating flicker</strong>. Leo must update the outline pane with minimum flicker.
Various versions of Leo have approached this problem in different ways. The
drawing code in leo.py is robust, flexible, relatively simple and should work in
almost any conceivable environment. Leo assumes that all code that changes the
outline pane will be enclosed in matching calls to the c.beginUpdate and
c.endUpdate methods of the Commands class. c.beginUpdate() inhibits drawing
until the matching c.endUpdate(). These calls may be nested; only the outermost
call to c.endUpdate() calls c.redraw() to force a redraw of the outline pane.</p>
<p>Code may call c.endUpdate(flag) instead of c.endUpdate(). Leo redraws
the screen only if flag is true. This allows code to suppress redrawing entirely
when needed. For example, here is how the idle_body_key event handler in
leoTree.py conditionally redraws the outline pane:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">redraw_flag</span> <span class="o">=</span> <span class="n">false</span>
<span class="n">c</span><span class="o">.</span><span class="n">beginUpdate</span><span class="p">()</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">computeIcon</span><span class="p">()</span>
<span class="k">if</span> <span class="n">val</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">iconVal</span><span class="p">:</span>
        <span class="n">v</span><span class="o">.</span><span class="n">iconVal</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">redraw_flag</span> <span class="o">=</span> <span class="n">true</span>
<span class="n">c</span><span class="o">.</span><span class="n">endUpdate</span><span class="p">(</span><span class="n">redraw_flag</span><span class="p">)</span> <span class="c"># redraw only if necessary</span>
</pre></div>
</div>
<p>The leoTree class redraws all icons automatically when c.redraw() is called.
This is a major simplification compared to previous versions of Leo. The entire
machinery of drawing icons in the vnode class has been eliminated. The
v.computeIcon method tells what the icon should be. The v.iconVal ivar
tells what the present icon is. The event handler simply compares these two
values and sets redraw_flag if they don&#8217;t match.</p>
<p><strong>Handling events.</strong> Besides redrawing the screen, Leo must handle events or
commands that change the text in the outline or body panes.</p>
<p>The leoTree class contains all the event handlers for the body and outline
panes. The actual work is done in the idle_head_key and idle_body_key methods.
These routines are surprisingly complex; they must handle all the tasks
mentioned above, as well as others. The idle_head_key and idle_body_key methods
should not be called outside the leoTree class. However, it often happens that
code that handles user commands must simulate an event. That is, the code needs
to indicate that headline or body text has changed so that the screen may be
redrawn properly. The leoTree class defines the following simplified event
handlers: onBodyChanged, onBodyWillChange, onBodyKey, onHeadChanged and
onHeadlineKey. Commanders and subcommanders call these event handlers to
indicate that a command has changed, or will change, the headline or body text.
Calling event handlers rather than c.beginUpdate and c.endUpdate ensures that
the outline pane is redrawn only when needed.</p>
</div>
<div class="section" id="find-and-change-commands">
<h2><a class="toc-backref" href="#id5">Find and change commands</a><a class="headerlink" href="#find-and-change-commands" title="Permalink to this headline">¶</a></h2>
<p>The find and change commands are tricky; there are many details that must be
handled properly. The following principles govern the LeoFind class:</p>
<ol class="arabic simple">
<li>Find and Change commands initialize themselves using only the state of the
present Leo window. In particular, the Find class must not save internal
state information from one invocation to the next. This means that when the
user changes the nodes, or selects new text in headline or body text, those
changes will affect the next invocation of any Find or Change command.
Failure to follow this principle caused all kinds of problems in the Borland
and Macintosh codes. There is one exception to this rule: we must remember
where interactive wrapped searches start. This principle simplifies the code
because most ivars do not persist. However, each command must ensure that
the Leo window is left in a state suitable for restarting the incremental
(interactive) Find and Change commands. Details of initialization are
discussed below.</li>
<li>The Find and Change commands must not change the state of the outline or body
pane during execution. That would cause severe flashing and slow down the
commands a great deal. In particular, the c.selectPosition and c.editPosition
methods must not be called while looking for matches.</li>
<li>When incremental Find or Change commands succeed they must leave the Leo
window in the proper state to execute another incremental command. We
restore the Leo window as it was on entry whenever an incremental search
fails and after any Find All and Change All command. Initialization involves
setting the self.c, self.v, self.in_headline, self.wrapping and
self.s_text ivars.</li>
</ol>
<p>Setting self.in_headline is tricky; we must be sure to retain the state of the
outline pane until initialization is complete. Initializing the Find All and
Change All commands is much easier because such initialization does not depend
on the state of the Leo window. Using the same kind of text widget for both
headlines and body text results in a huge simplification of the code.</p>
<p>Indeed, the searching code does not know whether it is searching headline or
body text. The search code knows only that self.s_text is a text widget that
contains the text to be searched or changed and the insert and sel attributes
of self.search_text indicate the range of text to be searched. Searching
headline and body text simultaneously is complicated. The selectNextVnode()
method handles the many details involved by setting self.s_text and its insert
and sel attributes.</p>
</div>
<div class="section" id="key-handling">
<h2><a class="toc-backref" href="#id6">Key handling</a><a class="headerlink" href="#key-handling" title="Permalink to this headline">¶</a></h2>
<p>The following three sections deal with different aspects of how Leo handle&#8217;s
keystrokes that the user types. This is the most complex code in Leo.</p>
<div class="section" id="key-domains">
<h3>Key domains<a class="headerlink" href="#key-domains" title="Permalink to this headline">¶</a></h3>
<p>Leo&#8217;s key-handling code has almost nothing to do with supporting multiple guis.
Rather, the key-handling code is complex because it must deal with the following
four fundamentally different problem domains.</p>
<div class="section" id="domain-1-parsing-user-bindings-in-keys-mode-and-shortcut-nodes">
<h4>Domain 1: Parsing user bindings in &#64;keys, &#64;mode and &#64;shortcut nodes<a class="headerlink" href="#domain-1-parsing-user-bindings-in-keys-mode-and-shortcut-nodes" title="Permalink to this headline">¶</a></h4>
<p>In this domain, complexity arises from allowing the user a variety of
<em>equivalent</em> ways of specifying bindings. Furthermore, this domain allows the
user to specify modes and per-pane bindings. Thus, all these complexities are
unavoidable.</p>
</div>
<div class="section" id="domain-2-maintaining-and-using-binding-tables">
<h4>Domain 2: Maintaining and using binding tables<a class="headerlink" href="#domain-2-maintaining-and-using-binding-tables" title="Permalink to this headline">¶</a></h4>
<p>The result of parsing user bindings are a set of binding tables. These tables
are complex, but we need not go into details here because only one method,
k.masterKeyHandler (and its helper, getPaneBinding) uses the tables.</p>
<p>The only thing we have to remember about the binding tables is that bindings are
expressed in terms of so-called <strong>strokes</strong>.  Strokes are the &#8220;official&#8221; form of
every user binding.  The essential property of a stroke is that it contains
<em>all</em> the information required to handle the stroke: Leo can unambiguously
determine exactly what a stroke means and what bindings are in effect for a
stroke.  If necessary, Leo can correctly insert the proper character
<em>corresponding</em> to the stroke into any text widget.</p>
<p>This correspondence (association) between the stroke and the actual
character to be inserted into text widgets is crucial.  This
correspondence is created in the next domain.</p>
<p>Anticipating a bit, for any incoming key event, event.stroke is the
stroke, and event.char is the character (if any) that <em>might</em>
(depending on bindings) be inserted into text widgets.</p>
<p><strong>New in Leo 4.9</strong>: k.stroke2char calculates the to-be-inserted char from
any stroke.</p>
</div>
<div class="section" id="domain-3-translating-incoming-key-events-into-standard-events">
<h4>Domain 3: Translating incoming key events into standard events<a class="headerlink" href="#domain-3-translating-incoming-key-events-into-standard-events" title="Permalink to this headline">¶</a></h4>
<p>The eventFilter method in qtGui.py creates leoKeyEvent objects.  Turning &#8220;raw&#8221;
Qt key events into leoKeyEvents is unavoidably complicated because eventFilter
(and its allies) <strong>must</strong> carefully compute the stroke corresponding to the raw
key event.  There is no way around this requirement if Leo&#8217;s binding machinery
in domain 2 is to work.  This code has been stable for a long time.</p>
</div>
<div class="section" id="domain-4-printing-key-bindings-in-a-human-readable-format">
<h4>Domain 4: Printing key bindings in a human-readable format<a class="headerlink" href="#domain-4-printing-key-bindings-in-a-human-readable-format" title="Permalink to this headline">¶</a></h4>
<p>It&#8217;s important not to forget this domain: there are some situations in which we
want to represent &#8216;b&#8217;,&#8217;r&#8217;,&#8217;n&#8217; and &#8216;t&#8217; as &#8216;BackSpace&#8217;,&#8217;Linefeed&#8217;,&#8217;Return&#8217; and
&#8216;Tab&#8217;.</p>
</div>
</div>
<div class="section" id="key-bindings">
<h3>Key bindings<a class="headerlink" href="#key-bindings" title="Permalink to this headline">¶</a></h3>
<p>There are two kinds of bindings, gui bindings and pane bindings.</p>
<p><strong>Gui bindings</strong> are the actual binding as seen by  whatever gui is in effect.
Leo binds every key that has a binding to k.masterKeyHander.</p>
<p>At present Leo makes gui bindings in several places, all equivalent.
Bindings are made to callbacks, all of which have this form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">event</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span><span class="n">stroke</span><span class="o">=</span><span class="n">stroke</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">k</span><span class="o">.</span><span class="n">masterKeyHandler</span><span class="p">(</span><span class="n">event</span><span class="p">,</span><span class="n">stroke</span><span class="p">)</span>
</pre></div>
</div>
<p>As a result, changing gui bindings actually has no effect whatever.
It would be clearer to have a single place to make these bindings...</p>
<p>In any case, the purpose of these callbacks is to capture the value of &#8216;stroke&#8217; so
that it can be passed to k.masterKeyHandler.
This relieves k.masterKeyHandler of the impossible task of computing the stroke from the event.</p>
<p><strong>Important</strong>:  No function argument is ever passed to k.masterKeyHandler from these callbacks,
because k.masterKeyHandler binds keys to command handlers as described next.</p>
<p><strong>Pane bindings</strong> are bindings represented by various Python dictionaries in the
keyHandlerClass (see below). k.masterKeyHandler and its helpers use these
dictionaries to call the proper command or mode handler. This logic is hairy,
but it is completely separate from the gui binding logic.</p>
<p>Here are the dictionaries that k.masterKeyHandler uses:</p>
<ul class="simple">
<li>c.commandsDict:
Keys are minibuffer command names; values are functions f.</li>
<li>k.inverseCommandsDict:
Keys are f.__name__l values are emacs command names.</li>
<li>k.bindingsDict:
Keys are shortcuts; values are <em>lists</em> of g.bunch(func,name,warningGiven).</li>
<li>k.masterBindingsDict:
Keys are pane names: &#8216;all&#8217;,&#8217;text&#8217;,etc. or mode names.
Values are dicts:  keys are strokes; values are g.Bunch(commandName,func,pane,stroke).</li>
<li>k.modeWidgetsDict:
Keys are mode names; values are lists of widgets to which bindings have been made.</li>
<li>k.settingsNameDict:
Keys are lowercase settings; values are &#8216;real&#8217; Tk key specifiers.
Important: this table has no inverse.</li>
<li>inverseBindingDict:
This is <em>not</em> an ivar; it is computed by k.computeInverseBindingDict().
Keys are emacs command names; values are <em>lists</em> of shortcuts.</li>
</ul>
</div>
<div class="section" id="handling-key-events">
<h3>Handling key events<a class="headerlink" href="#handling-key-events" title="Permalink to this headline">¶</a></h3>
<div class="section" id="all-events-are-key-events">
<h4>All events are key events<a class="headerlink" href="#all-events-are-key-events" title="Permalink to this headline">¶</a></h4>
<p>All event objects passed around Leo are <em>key</em> event objects. Taking a look at
the eventFilter method, we see clearly see that <em>only</em> key events ever get
passed to Leo&#8217;s core. All other events are handled by Qt-specific event
handlers.</p>
<p>As can be seen, these non-key events <em>can</em> be passed to Leo, but only as the
event arg in g.doHook (!) At present, no plugin ever calls k.masterKeyHandler.
The only call to k.masterKeyHandler in qtGui.py is the expected call in
eventFilter.</p>
<p>There are other calls to k.masterKeyHandler in Leo&#8217;s core, but we can prove (by
induction, if you will), that all events passed to k.masterKeyHandler are proper
leoKeyEvent objects.</p>
</div>
<div class="section" id="c-check-event">
<h4>c.check_event<a class="headerlink" href="#c-check-event" title="Permalink to this headline">¶</a></h4>
<p>The essential invariant is that the events passed to Leo&#8217;s core methods really
are leoKeyEvent objects created by qtGui.py.  Rather than asserting this
invariant, the code will contains calls to c.check_event in essential places.
c.check_event is a &#8220;relaxed&#8221; place to do as much error checking is needed.  In
particular, running the unit tests calls c.check_event many times.</p>
<p>c.check_event is a happy &#8220;accident&#8221;.  It turns out to be the essential
consistency check that continually verifies that the Qt event methods are
delivering the expected keys to k.masterKeyHandler.</p>
</div>
</div>
<div class="section" id="about-the-keystroke-class">
<h3>About the KeyStroke class<a class="headerlink" href="#about-the-keystroke-class" title="Permalink to this headline">¶</a></h3>
<p>The KeyStroke class distinguish between &#8220;raw&#8221; user settings
and the &#8220;canonicalized&#8221; form used throughout Leo. Indeed,
the ability to explicitly distinguish between the two, using
type checking, substantially clarifies and simplifies the
code.</p>
<p>The KeyStroke class makes possible vital type-related
assertions. Knowing <em>for sure</em> exactly what crucial data is
and what it means is a huge step forward.</p>
<p>Objects of the KeyStroke class can be used <em>exactly</em> as a
strings may be used:</p>
<p>A. KeyStroke objects may be used as dictionary keys, because
they have __hash__ methods and all the so-called rich
comparison methods: __eq__, __ne__, __ge__, __gt__, __le__
and __lt__. Note that KeyStroke objects may be compared with
other KeyStroke objects, strings and None.</p>
<p>B. At present, KeyStroke objects supports the find, lower
and startswith methods. This simplifies the code
substantially: we can apply these methods to either strings
or KeyStroke objects, so there is no need to create
different versions of the code depending on the value of
g.new_strokes.</p>
<p>However, having the KeyStroke class support string methods
is bad design. Indeed, it is a symptom that the client code
that uses KeyStroke objects knows too much about the
internals of KeyStroke objects. Instead, the KeyStroke class
should have higher-level methods that use s.find, s.lower
and s.startswith internally.</p>
<p>You could say that the fact that code in leoKeys.py calls
s.find, s.lower and s.startswith is a symptom of non OO
programming. The internal details of settings and strokes
&#8220;pollutes&#8221; the code. This must be fixed. This will likely
create opportunities for further simplifications.</p>
<p>&gt; Why not just have .s attribute in KeyStroke, that contains
the string version?</p>
<p>It is truly impossible to understand the key code without
knowing whether an object is a string representing a user
setting or the canonicalized version used in Leo&#8217;s core,
that is, a KeyStroke object. Using ks.s instead of ks
destroys precisely the information needed to understand the
code.</p>
<p>Again, this is not a theoretical concern. The key code now
contains assertions of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">assert</span> <span class="n">g</span><span class="o">.</span><span class="n">isStroke</span><span class="p">(</span><span class="n">stroke</span><span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">assert</span> <span class="n">g</span><span class="o">.</span><span class="n">isStrokeOrNone</span><span class="p">(</span><span class="n">stroke</span><span class="p">)</span>
</pre></div>
</div>
<p>Getting these assertions to pass in <em>all</em> situations
required several important revisions of the code. The code
that makes the assertions pass is &#8220;innocuous&#8221;, that is,
almost invisible in the mass of code, but obviously, these
small pieces of code are vital.</p>
<p>This is in no way a violation of OO principles. The code is
not dispatching on the type of objects, it is merely
enforcing vital consistency checks. This code is complex:
confusion about the types of objects is intolerable.
Happily, the resulting clarity allows the code to be
substantially simpler than it would otherwise be, which in
turn clarifies the code further, and so on...</p>
</div>
<div class="section" id="simplifying-the-qt-input-code">
<h3>Simplifying the Qt input code<a class="headerlink" href="#simplifying-the-qt-input-code" title="Permalink to this headline">¶</a></h3>
<p>The Qt key input code can be greatly simplified by calling a
new k.makeKeyStrokeFromData factory method. At present, the
Qt key input code knows <em>all</em> the details of the format of
<em>canonicalized</em> settings. This is absolutely wretched
design.</p>
<p>Instead, the Qt input key code should simply pass the key
modifiers and other key information to
k.makeKeyStrokeFromData, in a some kind of &#8220;easy&#8221; format.
For example, the Qt input key code would represent the
internal Qt modifiers as lists of strings like &#8220;alt&#8221;,
&#8220;ctrl&#8221;, &#8220;meta&#8221;, &#8220;shift&#8221;. k.makeKeyStrokeFromData would then
create a <em>user</em> setting from the components, and then call
k.strokeFromSetting to complete the transformation.</p>
</div>
<div class="section" id="typed-dicts">
<h3>Typed dicts<a class="headerlink" href="#typed-dicts" title="Permalink to this headline">¶</a></h3>
<p>Leo&#8217;s key dictionaries will always be complex, but basing
them on the TypedDict class is a major improvement.</p>
<p>The g.TypedDict and g.TypedDictOfLists classes are useful
for more than type checking: they have unique names and a
dump method that dumps the dict in an easy-to-read format
that includes the name, and valid types for keys and values.</p>
<p>Plain dicts do have their uses, but for &#8220;long-lived&#8221; dicts,
and dicts passed around between methods, plain dicts are as
ill-advised as g.Bunches.</p>
</div>
</div>
<div class="section" id="nodes">
<h2><a class="toc-backref" href="#id7">Nodes</a><a class="headerlink" href="#nodes" title="Permalink to this headline">¶</a></h2>
<p>The vnode class is Leo&#8217;s fundamental model class. A <strong>vnode</strong> represents the
data represented by headlines. As of Leo 4.7, all clones of a node are in fact
<strong>exactly the same node</strong>.</p>
<p>The vnode contains <strong>all</strong> data associated with a node. A vnode contains
headline text, body text, and <strong>user attributes</strong>, uA&#8217;s for short.</p>
<p>Because Leo has unlimited Undo commands, Leo deletes vnodes only when a window
closes. Leo deletes nodes indirectly using destroy methods. Several classes,
including the vnode, leoFrame and leoTree classes, have destroy methods. destroy
methods merely clear links so that Python&#8217;s reference counting mechanisms will
eventually delete vnodes and other data when a window closes.</p>
<p>Leo&#8217;s XML file format uses <strong>tx</strong> and <strong>t</strong> attributes to associate &lt;v&gt; elements
with &lt;t&gt; elements. &lt;v&gt; elements represent nodes. &lt;t&gt; elements represent the body
text of nodes. This is a (somewhat dubious) space optimization. The values of tx
and t attributes are <strong>gnx&#8217;s</strong> (global node indices). These indices do not
change once a node has created.</p>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id8">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>All versions of Leo are organized as a collection of classes. The general
organization of Leo has remained remarkably stable throughout all versions of
Leo, although the names of classes are different in different versions.
Smalltalk&#8217;s Model/View/Controller terminology is a good way think about Leo&#8217;s
classes. <strong>Model classes</strong> represent the fundamental data. The vnode
class is Leo&#8217;s primary model class.</p>
<p><strong>View classes</strong> draw the screen. The main view classes are leoFrame.py and
leoTree.py. The colorizer class in leoColor.py handles syntax coloring in the
body pane. Leo&#8217;s view classes know about data stored in the vnode class. Most
events (keystrokes and mouse actions) in the outline and body pane are handled
in the leoTree class. The leoFrame class also creates the Leo window, including
menus, and dispatches the appropriate members of the controller classes in
response to menu commands.</p>
<p><strong>Controller classes</strong> (aka commanders) control the application. In Leo,
controllers mostly handle menu commands. Commanders create subcommanders to
handle complex commands. The atFile class reads and writes files derived from
&#64;file trees. The LeoFind class handles the Find and Change commands. The
leoImportCommands class handles the Import and Export commands, and the undoer
class handles the Undo command. Other classes could be considered controller
classes.</p>
<p>Each Leo window has its own commander and subcommanders. Subcommanders are not
subclasses of their commander. Instead, subcommanders know the commander that
created them, and call that commander as needed. Commanders and subcommanders
call the model and view classes as needed. For example, the Commands class
handles outline commands. To move a headline, the commander for the window calls
a vnode move routine to alter the data, then calls the view class to redraw the
screen based on the new data.</p>
<p>A singleton instance of the <strong>LeoApp</strong> class represents the application itself.
All code uses the app() global function to gain access to this singleton member.
The ivars of the LeoApp object are the equivalent of Leo&#8217;s global variables.
leo.py uses no global Python variables, except the gApp variable returned by
app(). leoGlobals.py defines all application constants. Naturally, most
constants are local to the class that uses them.</p>
<p>Several classes combine aspects of model, view and controller. For example, the
<strong>LeoPrefs</strong> class represents user preferences (model), the Preference Panel
(view) and the Preferences menu command (controller). Similarly, the <strong>LeoFind</strong>
class represents find settings, the Find/Change dialog, and the Find/Change
commands.</p>
<p>We use the following convention throughout this documentation. Any variable
named c is a commander, i.e., an instance of the Commands class in
leoCommands.py. Variables named v are vnodes. These classes are defined in
leoNodes.py.</p>
</div>
<div class="section" id="unicode">
<h2><a class="toc-backref" href="#id9">Unicode</a><a class="headerlink" href="#unicode" title="Permalink to this headline">¶</a></h2>
<p>Leo uses unicode objects in vnodes to denote headline and body text.
Note that unicode strings have no encoding; only plain strings have encodings.
This means that once an (encoded) plain string has been converted to a unicode
string it doesn&#8217;t matter how the unicode string was created. This is the key
that makes Leo&#8217;s new code robust: internally Leo never has to worry about
encodings. Encoding matter only when encoded strings are converted to and from
Unicode. This happens when Leo reads or writes files.</p>
<p>Python expressions that mix unicode strings u and plain strings s, like one of these:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span> <span class="o">+</span> <span class="n">s</span>
<span class="n">u</span> <span class="o">==</span> <span class="n">s</span>
<span class="n">u</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
</pre></div>
</div>
<p>are promoted to unicode objects using the &#8220;system encoding&#8221;. This encoding
should never be changed, but we can&#8217;t assume that we know what it is, so for
safety we should assume the most restrictive encoding, namely &#8220;ascii&#8221;. With this
assumption, Leo&#8217;s code can&#8217;t throw an exception during these promotions provided
that:</p>
<ul class="simple">
<li>Leo converts all text to unicode when Leo reads files or gets text from
text widgets.</li>
<li>All string literals in Leo&#8217;s code have only ascii characters.</li>
</ul>
</div>
<div class="section" id="unlimited-undo">
<h2><a class="toc-backref" href="#id10">Unlimited undo</a><a class="headerlink" href="#unlimited-undo" title="Permalink to this headline">¶</a></h2>
<p>Unlimited undo is straightforward; it merely requires that all commands that
affect the outline or body text must be undoable. In other words, everything
that affects the outline or body text must be remembered. We may think of all
the actions that may be Undone or Redone as a string of beads (undo nodes).</p>
<p>Undoing an operation moves backwards to the next bead; redoing an operation moves
forwards to the next bead. A bead pointer points to the present bead. The bead
pointer points in front of the first bead when Undo is disabled. The bead
pointer points at the last bead when Redo is disabled. An undo node is a Python
dictionary containing all information needed to undo or redo the operation. The
Undo command uses the present bead to undo the action, then moves the bead
pointer backwards.</p>
<p>The Redo command uses the bead after the present bead to redo the action, then
moves the bead pointer forwards. All undoable operations call setUndoParams() to
create a new bead. The list of beads does not branch; all undoable operations
(except the Undo and Redo commands themselves) delete any beads following the
newly created bead. I did not invent this model of unlimited undo.
I first came across it in the documentation for Apple&#8217;s Yellow Box classes.</p>
</div>
<div class="section" id="leo-s-load-process">
<h2><a class="toc-backref" href="#id11">Leo&#8217;s load process</a><a class="headerlink" href="#leo-s-load-process" title="Permalink to this headline">¶</a></h2>
<p>Leo reads local files twice. The first load discovers the
settings to be used in the second load. This ensures that
proper settings are <em>available</em> during the second load.</p>
<p>Ctors init settings &#8220;early&#8221;, before calling the ctors for
subsidiary objects. This ensures that proper settings are
<em>in effect</em> for the subsidiary ctors.</p>
<p>After creating all subsidiary objects, c.__init__ simply
calls c.finishCreate! Creating Commands objects is now
completely self-contained. In particular, c.__init__ now
creates the fully-inited gui frame. This is a revolution in
Leo&#8217;s startup code! c.__init__ no longer needs a frame
argument, a surprisingly important conceptual
simplification.</p>
<p>The old code inited Leo windows in several <em>places</em>
(c.__init__, the end of g.app.newLeoCommanderAndFrame and
the end of g.openWithFileName) and in several <em>phases</em>,
(g.app.newCommanderAndFrame, g.openWithFileName and
c.finishCreate.)</p>
<p>The new code has c.__init__ do <em>all</em> the work, in one place,
and in one phase. This is supremely important for future
maintainers. The old code was difficult for me to understand
yesterday, even after a full week of study. The new code is
a simple as could possibly be imagined. This is a gigantic
step forward for Leo.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="leo_toc.html">
              <img class="logo" src="_static/Leo4-80-border.jpg" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="history.html"
                        title="previous chapter">History of Leo</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="whitepapers.html"
                        title="next chapter">White Papers</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="whitepapers.html" title="White Papers"
             >next</a> |</li>
        <li class="right" >
          <a href="history.html" title="History of Leo"
             >previous</a> |</li>
        <li><a href="leo_toc.html">Leo 4.9 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Edward K. Ream.
      Last updated on Feb 27, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>